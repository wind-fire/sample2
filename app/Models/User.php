<?php

namespace App\Models;

use App\Notifications\ResetPassword;
use Illuminate\Notifications\Notifiable;
use Illuminate\Foundation\Auth\User as Authenticatable;
use Illuminate\Support\Facades\Auth;

class User extends Authenticatable
{
    use Notifiable;

    /**
     * The attributes that are mass assignable.
     *
     * @var array
     */
    protected $fillable = [
        'name', 'email', 'password',
    ];

    /**
     * The attributes that should be hidden for arrays.
     *
     * @var array
     */
    protected $hidden = [
        'password', 'remember_token',
    ];

    /*如果我们需要在模型被创建之前进行一些设置，则可以通过监听 creating 方法来做到。该方法是由 Eloquent 模型触发的一个事件。
    事件是 Laravel 提供一种简单的监听器实现，我们可以对事件进行监听和订阅，从而在事件被触发时接收到响应并执行一些指定操作。
    Eloquent 模型默认提供了多个事件，我们可以通过其提供的事件来监听到模型的创建，更新，删除，保存等操作。
    creating 用于监听模型被创建之前的事件，created 用于监听模型被创建之后的事件。
    接下来我们要生成的用户激活令牌需要在用户模型创建之前生成，因此需要监听的是 creating 方法。*/
    public static function boot()
    {
        parent::boot(); // TODO: Change the autogenerated stub
        static::creating(function ($user){
            $user->activation_token=str_random(30);
        });
    }

    /*从gravatar 获取用户头像*/
    public function gravatar($size = '100')
    {
        $hash = md5( strtolower( trim($this->attributes['email']) ) );
        return "http://www.gravatar.com/avatar/$hash?s=$size";
    }

    /*发送重置密码通知*/
    public function sendPasswordResetNotification($token)
    {
        $this->notify(new ResetPassword($token));
    }

    /*一个用户有多条微博*/
    public function statuses()
    {
        return $this->hasMany(Status::class);
    }

    /*在开始之前，我们需要在用户模型中定义一个 feed 方法，该方法将当前用户发布过的所有微博从数据库中取出，并根据创建时间来倒序排序。
    在后面我们为用户增加关注人的功能之后，将使用该方法来获取当前用户关注的人发布过的所有微博动态。现在的 feed 方法定义如下*/
    /*public function feed()
    {
        return $this->statuses()->orderBy('created_at','desc');
    }*/

    /*下面的方法做了以下几个事情：

    通过 followings 方法取出所有关注用户的信息，再借助 pluck 方法将 id 进行分离并赋值给 user_ids；
    将当前用户的 id 加入到 user_ids 数组中；
    使用 Laravel 提供的 查询构造器 whereIn 方法取出所有用户的微博动态并进行倒序排序；
    我们使用了 Eloquent 关联的 预加载 with 方法，预加载避免了 N+1 查找的问题，大大提高了查询效率。N+1 问题 的例子可以阅读此文档 Eloquent 模型关系预加载 。
    这里需要注意的是 Auth::user()->followings 的用法。我们在 User 模型里定义了关联方法 followings()，关联关系定义好后，我们就可以通过访问 followings 属性直接获取到关注用户的 集合。这是 Laravel Eloquent 提供的「动态属性」属性功能，我们可以像在访问模型中定义的属性一样，来访问所有的关联方法。

    还有一点需要注意的是 $user->followings 与 $user->followings() 调用时返回的数据是不一样的， $user->followings 返回的是 Eloquent：集合 。而 $user->followings() 返回的是 数据库请求构建器 ，followings() 的情况下，你需要使用：

    $user->followings()->get()
    或者 ：

    $user->followings()->paginate()
    方法才能获取到最终数据。可以简单理解为 followings 返回的是数据集合，而 followings() 返回的是数据库查询语句。如果使用 get() 方法的话：*/
    public function feed()
    {
        $user_ids = Auth::user()->followings->pluck('id')->toArray();
        array_push($user_ids,Auth::user()->id);
        return Status::whereIn('user_id',$user_ids)
            ->with('user')
            ->orderBy('created_at','desc');
    }

    /*获取粉丝关系列表*/
    public function followers()
    {
        /*在 Laravel 中会默认将两个关联模型的名称进行合并并按照字母排序，因此我们生成的关联关系表名称会是 followers_user。
        我们也可以自定义生成的名称，把关联表名改为 followers。
        除了自定义合并数据表的名称，我们也可以通过传递额外参数至 belongsToMany 方法来自定义数据表里的字段名称。
        belongsToMany 方法的第三个参数 user_id 是定义在关联中的模型外键名，而第四个参数 follower_id 则是要合并的模型外键名。*/
        return $this->belongsToMany(User::class,'followers','user_id','follower_id');
    }

    /*在我们为用户和粉丝模型进行了多对多关联之后，便可以使用 Eloquent 模型为多对多提供的一系列简便的方法。如使用 attach 方法或 sync 方法在中间表上创建一个多对多记录，
    使用 detach 方法在中间表上移除一个记录，创建和移除操作并不会影响到两个模型各自的数据，所有的数据变动都在 中间表 上进行。attach, sync, detach 这几个方法都允许传入 id 数组参数。*/
    /*获取用户关系列表*/
    public function followings()
    {
        return $this->belongsToMany(User::class,'followers','follower_id','user_id');
    }

    /*关注用户*/
    public function follow($user_ids)
    {
        /*is_array 用于判断参数是否为数组，如果已经是数组，则没有必要再使用 compact 方法。
        我们并没有给 sync 和 detach 指定传递参数为用户的 id，这两个方法会自动获取数组中的 id。*/
        if(!is_array($user_ids)){
            $user_ids = compact('user_ids');
        }
        $this->followings()->sync($user_ids,false);

    }

    /*取消关注*/
    public  function unfollow($user_ids)
    {
        if(!is_array($user_ids)){
            $user_ids = compact('user_ids');
        }
        $this->followings()->detach($user_ids);
    }

    public function isFollowing($user_id)
    {
        /*// 1. 返回的是一个 HasMany 对象
        $this->followings()
        // 2. 返回的是一个 Collection 集合
        $this->followings
        // 3. 第2个其实相当于这样
        $this->followings()->get()
        // 如果不需要条件直接使用 2 那样，写起来更短*/

        /*这里需要注意的是 Auth::user()->followings 的用法。我们在 User 模型里定义了关联方法 followings()，关联关系定义好后，我们就可以通过访问 followings 属性直接获取到关注用户的 集合。这是 Laravel Eloquent 提供的「动态属性」属性功能，我们可以像在访问模型中定义的属性一样，来访问所有的关联方法。

        还有一点需要注意的是 $user->followings 与 $user->followings() 调用时返回的数据是不一样的， $user->followings 返回的是 Eloquent：集合 。而 $user->followings() 返回的是 数据库请求构建器 ，followings() 的情况下，你需要使用：

        $user->followings()->get()

        或者 ：

        $user->followings()->paginate()

        方法才能获取到最终数据。可以简单理解为 followings 返回的是数据集合，而 followings() 返回的是数据库查询语句。如果使用 get() 方法的话：

        $user->followings == $user->followings()->get() // 等于 true*/
        return $this->followings->contains($user_id);

    }


}
